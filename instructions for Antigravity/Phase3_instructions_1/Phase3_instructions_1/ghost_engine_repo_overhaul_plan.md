# Ghost Engine Phase 3 Overhaul & Re‑organisation Plan

### Why re‑organise?
The existing GitHub repository grew organically from the Phase 1 ASCII **GE Doom** experiment and a Phase 2 attempt at a 3D port.  Current files mix demo scripts, AWS infrastructure, worker/orchestrator services and a minimal runtime.  The Phase 3 vision reframes Ghost Engine as an **open‑source interoperability kernel** that turns outputs from large world models into **deterministic, playable worlds**.  The one‑pager notes that interactive experiences currently break on non‑determinism, engine lock‑in, missing provenance, regression risk when models change and cost blow‑ups without caching【186494871868089†L74-L88】.  Phase 3 positions Ghost Engine to fix those problems by focusing on **open orchestration, determinism, provenance, evaluation and modular adapters**【186494871868089†L74-L88】.  The roadmap further explains that the core of Phase 3 is a **Ghost Protocol** with stable schemas (WorldState, AssetManifest, InteractionSpec, ProvenanceSpec, EvalSpec and AdapterSpec) and a **reference platform** containing a deterministic kernel, orchestration fabric, Adapter SDK and reference runtimes【186494871868089†L74-L88】【186494871868089†L75-L88】.

To support this pivot, the monorepo should be reorganised so that the **kernel and protocol are first‑class**, adapters are pluggable, and demos/runtimes are clearly separated from the core.  Below is a proposed structure and migration plan.

## Proposed monorepo structure

| Top‑level folder | Purpose | Notes |
|---|---|---|
| `protocol/` | JSON schema & TypeScript definitions for Ghost Protocol v0.1 (WorldState, AssetManifest, InteractionSpec, ProvenanceSpec, EvalSpec, AdapterSpec)【186494871868089†L74-L88】 | Include versioning rules and code generators to keep schemas in sync. |
| `kernel/` | Deterministic simulation core implementing **WorldState, Tick loop, event log** and deterministic RNG; snapshot/restore & replay【186494871868089†L74-L88】. | Should be library‑agnostic (no rendering).  Provide unit tests that verify determinism across seeds. |
| `adapters/` | Adapter SDK and implementations.  Contains: `sample-provider/` (bundled assets for offline demo), `marble-provider/` (calls the Marble API, normalises exports to AssetManifest + InteractionSpec) and future adapters.  Each adapter exposes `generate()`, `fetchAssets()`, `getColliders()` and `metadata()`【186494871868089†L74-L88】. | Define common interface and caching/provenance hooks.  Ensure adapters can be swapped—Marble is marquee but never a dependency【186494871868089†L74-L88】. |
| `services/` | Runtime services.  Split into `orchestrator/` (job scheduling, caching, retries, policy, local‑first; optional cloud adapter), `ingest/` (builds navmesh, spawn graph, triggers from adapter exports), and `worker/` (may run plugin‑based world generation).  Provide infrastructure config (Docker, local dev, Terraform) under `services/infra/`. | The orchestrator and ingestion services implement the “Generate → Import → Interactive” flow【186494871868089†L74-L88】. |
| `cli/` | Command‑line tools – `ge new`, `ge run`, `ge replay`, `ge export` – for creating new projects, running a world in the reference runtime, replaying a seed and exporting to glTF/GLB or video【186494871868089†L74-L88】. | Use the kernel & protocol packages; avoid directly calling orchestrator services. |
| `runtimes/` | Reference runtimes.  Include `ge-doom/` (deterministic ASCII debug runtime) and `viewer-3d/` (minimal Three.js/Godot/Unity sandbox)【186494871868089†L74-L88】.  Runtimes should consume only the kernel’s WorldState and Events and avoid introducing engine‑specific logic【186494871868089†L74-L88】. |
| `exporters/` | Transmedia exporters for glTF/GLB, USD‑lite, “record” fly‑through video and future VR/AR templates【186494871868089†L74-L88】. |
| `docs/` | Architecture documentation, protocol specification, adapter authoring guide, contribution guidelines and developer quickstart.  Include the one‑pager and Phase 3 roadmap for context. |
| `examples/` | Sample worlds, demo scripts and evaluation suites.  Should be lightweight and reference the CLI instead of custom scripts. |
| `tests/` | Unit and integration tests; determinism tests for the kernel; evaluation harness verifying collision sanity, nav connectivity and gameplay metrics【186494871868089†L74-L88】.  Integrate with CI so that PRs run the eval harness【186494871868089†L74-L88】. |

### Additional reorganisation tasks

1. **Kernel‑first README and contribution docs:** The top‑level `README.md` should explain Ghost Engine’s mission: *open orchestration + determinism + provenance + eval + adapters*【186494871868089†L74-L88】.  Provide a high‑level architecture diagram and quick‑start instructions for running the SampleProvider demo locally.  Include a Code of Conduct and contribution guidelines.
2. **Extract protocol schemas:** Move existing `levelspec` JSON schema into `protocol/` and expand it to cover the Ghost Protocol types (WorldState, AssetManifest, InteractionSpec, ProvenanceSpec and EvalSpec).  Generate TS types from the schemas to ensure type‑safety across packages.
3. **Refactor GE Doom runtime:** The current `ge-doom/runtime.js` is a monolithic file that loads a LevelSpec and runs a CLI game.  Refactor it to consume WorldState & Events emitted by the kernel and move it into `runtimes/ge-doom/`.  Keep it simple; the roadmap stresses that rendering is a non‑goal and the minimal viewer proves portability【186494871868089†L74-L88】.
4. **Create adapter SDK and SampleProvider:** Define an abstract `WorldProvider` interface with methods `generate()`, `fetchAssets()`, `getColliders()`, `metadata()`【186494871868089†L74-L88】.  Provide `sample-provider/` which uses bundled assets so the demo works offline, and `marble-provider/` which calls the Marble API and normalises exports to AssetManifest + InteractionSpec【186494871868089†L74-L88】.  Adapters must capture provenance (prompt, seed, model version) and support content‑addressed caching.
5. **Orchestration fabric:** Move the existing Node.js orchestrator and worker into `services/orchestrator` and `services/worker`.  Add a `services/ingest` component that converts adapter outputs into kernel inputs (collision map, navmesh, spawn/trigger graphs)【186494871868089†L74-L88】.  The orchestrator should support local queues with retries and concurrency limits; optional cloud adapters may be provided but should not be required【186494871868089†L74-L88】.
6. **CLI skeleton:** Replace the ad‑hoc demo scripts (`demo-pack.mjs`, `demo-readiness-report.js`) with a unified CLI under `cli/`.  Commands should wrap orchestrator APIs and run the kernel & runtimes.  For example:
   - `ge new` – create a new project scaffold.
   - `ge run --prompt "tiny dungeon" --provider sample --runtime doom` – generate a world and launch the specified runtime.
   - `ge replay --seed <s>` – replay an existing world using the deterministic kernel.
   - `ge export --format glb` – export assets using an exporter.
7. **Evaluation harness:** Implement the eval suite described in the roadmap: determinism regression, collision sanity, nav connectivity and gameplay metrics【186494871868089†L74-L88】.  Integrate the harness with CI so that pull requests run these tests.  Keep baseline snapshots per provider/version and report pass/fail deltas during the demo【186494871868089†L74-L88】.
8. **Infrastructure separation:** Move Terraform, Docker Compose and AWS‑specific scripts into `services/infra/` with clear instructions.  Provide local‑first defaults (Docker Compose) and optional cloud deployment modules.  The roadmap emphasises that **cloud is optional** and demos should work locally【186494871868089†L74-L88】.
9. **Guardrails & governance:** Adopt the guardrails from the roadmap: (i) every new feature must touch WorldState/Tick/Events or Eval/Provenance; (ii) rendering improvements should not creep into the kernel; (iii) keep adapters swappable – Marble is an adapter, not a core dependency【186494871868089†L74-L88】.  Document these rules in `docs/CONTRIBUTING.md` to prevent scope creep.
10. **Roadmap alignment:** Use the 12‑week schedule in the roadmap to prioritise tasks.  Week 1 covers setting up the monorepo, protocol schemas and CLI skeleton; Weeks 2–4 focus on the deterministic kernel, GE Doom runtime and adapter SDK; Weeks 5–7 integrate Marble and ingestion; Weeks 8–10 build the orchestration fabric, eval harness and exporters; Weeks 11–12 package docs and prepare the CodeLaunch demo【186494871868089†L74-L88】.  Future quarters can extend the adapter ecosystem, add thin Unity/Unreal bridges and introduce omnichannel exports【186494871868089†L74-L88】.

## Summary
The existing repository has served well for Phase 1/2 demos but mixes demo scripts, orchestrator/worker code and a rudimentary runtime.  Phase 3’s goal is to position Ghost Engine as an **interoperability kernel**, not a one‑off demo.  Reorganising into a **kernel‑first monorepo with a clear protocol**, pluggable adapters and separated runtimes will ensure the project scales and remains vendor‑agnostic.  By following the roadmap’s guardrails – determinism, provenance, evaluation and adapter modularity – the team can avoid drift and deliver a compelling CodeLaunch demo while laying the foundation for long‑term growth.
